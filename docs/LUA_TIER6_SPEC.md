# Tier 6: Developer Experience - Remaining Work

**Status:** ‚öôÔ∏è **IN PROGRESS**

## What's Already Implemented

| Component | Status |
|-----------|--------|
| Interactive REPL (`niri msg lua`) | ‚úÖ Complete |
| Documentation (LUA_GUIDE.md, LUA_QUICKSTART.md, etc.) | ‚úÖ Complete |
| Example Scripts (10 in `examples/`) | ‚úÖ Complete |
| Type Generation Infrastructure | ‚úÖ Complete (Option C: Registry) |

## Implementation Approach: Option C - Custom Type Registry

After evaluating three approaches for auto-generating type definitions:

| Approach | Description | Chosen? |
|----------|-------------|---------|
| **Option A**: Annotation-based | Parse `//! @lua_*` comments in Rust | ‚ùå |
| **Option B**: mlua-extras | Use `TypedUserData` trait | ‚ùå |
| **Option C**: Custom Registry | Rust struct defines API schema | ‚úÖ |

**Option C** was selected because:
1. **Type-safe source of truth** - Schema is Rust code; compiler catches errors
2. **No parsing complexity** - No regex/text parsing of source files  
3. **No external deps** - Pure Rust, no proc-macro crates
4. **Decoupled from impl** - Schema lives separately from mlua registration code

### Implementation Files

| File | Purpose |
|------|---------|
| `niri-lua/src/lua_api_schema.rs` | Schema types: `LuaApiSchema`, `ModuleSchema`, `FunctionSchema`, etc. |
| `niri-lua/src/api_registry.rs` | Complete API definition using schema types |
| `niri-lua/build.rs` | Generates `types/api.lua` from registry on each build |
| `niri-lua/types/api.lua` | Generated EmmyLua annotations for LSP |

### Output Format: EmmyLua Annotations

The generated type definitions use **EmmyLua annotation format** (not Luau native types) for compatibility with:
- **emmylua-analyzer-rust** (Neovim)
- **lua-language-server** (lua_ls)
- **Sumneko.lua** (VS Code)

Example generated output:
```lua
---@meta
-- THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT

---@alias Window { id: integer, title: string?, app_id: string?, ... }

---@class Timer
---@field id integer Unique timer identifier
local Timer = {}

---Start the timer with a delay and optional repeat interval
---@param delay_ms integer Delay in milliseconds
---@param repeat_ms? integer Repeat interval (0 for one-shot)
---@param callback fun() Callback function
---@return Timer
function Timer:start(delay_ms, repeat_ms, callback) end
```

## Remaining Work

### 1. EmmyLua Type Definitions

**Status:** üöß Schema complete, generation pending

**Files created:**
- ‚úÖ `niri-lua/src/lua_api_schema.rs` - Schema type definitions
- ‚úÖ `niri-lua/src/api_registry.rs` - Full API registry (~100 action methods, 5 UserData types, 7 type aliases)
- ‚úÖ `niri-lua/build.rs` - EmmyLua generator

**Status:** ‚úÖ Complete
- Build.rs generates `types/api.lua` on every `cargo build -p niri-lua`
- Schema/registry modules are standalone (not added to lib.rs, as they're reference-only)

### 2. LSP Configuration

**Status:** ‚úÖ Documented below

The generated `niri-lua/types/api.lua` provides EmmyLua annotations. Configure your LSP to include this file for autocomplete and type checking.

#### Neovim with emmylua-analyzer-rust

Add to your LSP configuration (e.g., `~/.config/nvim/lua/plugins/lsp.lua`):

```lua
-- Option 1: Using lspconfig
require("lspconfig").emmylua_ls.setup({
  settings = {
    emmylua = {
      workspace = {
        library = {
          -- Add niri type definitions (adjust path as needed)
          vim.fn.expand("~/.local/share/niri/types"),
          -- Or if developing niri itself:
          -- "/path/to/niri/niri-lua/types"
        }
      }
    }
  }
})

-- Option 2: Manual setup
vim.lsp.start({
  name = "emmylua",
  cmd = { "emmylua-analyzer-rust" },
  root_dir = vim.fn.getcwd(),
  settings = {
    emmylua = {
      workspace = {
        library = { vim.fn.expand("~/.local/share/niri/types") }
      }
    }
  }
})
```

#### Neovim with lua-language-server (lua_ls)

```lua
require("lspconfig").lua_ls.setup({
  settings = {
    Lua = {
      workspace = {
        library = {
          vim.fn.expand("~/.local/share/niri/types"),
        },
        -- Suppress "undefined global 'niri'" warnings
        checkThirdParty = false,
      },
      diagnostics = {
        globals = { "niri" },
      },
    }
  }
})
```

#### VS Code with Sumneko Lua

Create or update `.vscode/settings.json` in your niri config directory:

```json
{
  "Lua.workspace.library": [
    "~/.local/share/niri/types"
  ],
  "Lua.diagnostics.globals": ["niri"],
  "Lua.workspace.checkThirdParty": false
}
```

Or configure globally in VS Code settings (Ctrl+,):
1. Search for "Lua.workspace.library"
2. Add the path to `niri-lua/types/`

#### Installation of Type Definitions

Users can copy the generated types to a standard location:

```bash
# After building niri, install type definitions
mkdir -p ~/.local/share/niri/types
cp /path/to/niri/niri-lua/types/api.lua ~/.local/share/niri/types/

# Or symlink for automatic updates during development
ln -s /path/to/niri/niri-lua/types ~/.local/share/niri/types
```

### 3. Plugin Testing Framework

**File to create:** `niri-lua/src/testing.rs` or Lua module

Features needed:
- `test.describe()` / `test.it()` BDD-style test functions
- `test.assert()` with clear error messages
- Mock state for testing without running compositor
- Test runner that reports results

Example usage:
```lua
local test = require "niri.testing"

test.describe("Window Operations", function()
  test.it("should list windows", function()
    local windows = niri.state.windows()
    test.assert(type(windows) == "table")
  end)
end)

test.run()
```

### 4. Additional Example Plugins

Create in `examples/plugins/`:
- `column-stacker/` - Stack N windows in a column before creating new columns
- `workspace-namer/` - Auto-name workspaces based on open apps
- `app-launcher/` - Fuzzy app launcher with recent apps tracking
- `session-save/` - Save and restore window layouts

## Success Criteria

- [x] IDE autocomplete works in Neovim/VS Code with EmmyLua-compatible LSPs
- [x] Type definitions cover all public APIs using EmmyLua annotation syntax
- [x] LSP configuration documented for Neovim (emmylua-analyzer-rust, lua_ls) and VS Code
- [ ] Plugin testing framework functional (future work)
- [ ] 5+ example plugins demonstrate major features (10 examples exist in `examples/`)
